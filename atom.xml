<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>没名字的博客</title>
  
  
  <link href="http://zhuyuezy.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhuyuezy.github.io/"/>
  <updated>2021-12-03T14:36:05.948Z</updated>
  <id>http://zhuyuezy.github.io/</id>
  
  <author>
    <name>zhuyue</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跑路日记</title>
    <link href="http://zhuyuezy.github.io/2021/12/03/%E8%B7%91%E8%B7%AF%E6%97%A5%E8%AE%B0/"/>
    <id>http://zhuyuezy.github.io/2021/12/03/%E8%B7%91%E8%B7%AF%E6%97%A5%E8%AE%B0/</id>
    <published>2021-12-03T14:21:03.000Z</published>
    <updated>2021-12-03T14:36:05.948Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇没有营养的跑路日记，记录我从决定跑路到最终成功跑路（希望）的过程。</p><a id="more"></a><p>2021.12.3</p><p>在半个月无休、近一周无正常睡眠之后，我决定跑路。</p><p>毕业后入职现单位已经近一年五个月，从最初的好奇、信心满满到现在的疲惫、迷茫。工作累不是问题，又累又没希望最为致命。转头看看部门老员工，再干几年还是一样，无休止的加班，难以得到的正常节假日，永远的7x24待命。</p><p>我得跑。</p><p>再也不要做运维了，我要睡觉。</p><p>盘点一下现存技能，sql经常使用还算熟练，有时候写点python脚本方便自己工作，oc和c已经不记得了。已跟男友约好一天不学习转他100，加班到深夜除外，希望不要变成他月收+3000。就从把python再次学起来开始吧，争取年后能成功跑路。</p><p>！！跑路！！我要睡觉！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一篇没有营养的跑路日记，记录我从决定跑路到最终成功跑路（希望）的过程。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Python 3 读取文件错误：UnicodeDecodeError</title>
    <link href="http://zhuyuezy.github.io/2019/11/14/Python3-UnicodeDecodeError/"/>
    <id>http://zhuyuezy.github.io/2019/11/14/Python3-UnicodeDecodeError/</id>
    <published>2019-11-14T08:11:11.000Z</published>
    <updated>2020-09-28T02:33:42.847Z</updated>
    
    <content type="html"><![CDATA[<p>今天在Python 3中读取kaggle 2015提供的某.asm文件时，报错<br><code>UnicodeDecodeError:&#39;utf-8&#39; codec can&#39;t decode byte 0xa0 in position 6605: invalid start byte.</code></p><p>导致这个报错的原因是：该文件的编码方式为<code>ASCII text, with CRLF line terminators</code>，而不是utf-8。</p><a id="more"></a><p>解决方法多种：</p><p>1、改用Python 2，因为Python 2默认以字节流的方式读取文件;</p><p>2、基于与1同样的原因，可以在Python 3中以<code>&#39;rb&#39;</code>方式读取；</p><p>3、也可使用sublime等文本编辑软件，以<code>utf-8</code>编码重新存储该文件，再读取。</p><p>以上就是这个error的解决方法啦 ٩(ˊᗜˋ*)و</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天在Python 3中读取kaggle 2015提供的某.asm文件时，报错&lt;br&gt;&lt;code&gt;UnicodeDecodeError:&amp;#39;utf-8&amp;#39; codec can&amp;#39;t decode byte 0xa0 in position 6605: invalid start byte.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;导致这个报错的原因是：该文件的编码方式为&lt;code&gt;ASCII text, with CRLF line terminators&lt;/code&gt;，而不是utf-8。&lt;/p&gt;</summary>
    
    
    
    <category term="python" scheme="http://zhuyuezy.github.io/categories/python/"/>
    
    
    <category term="error" scheme="http://zhuyuezy.github.io/tags/error/"/>
    
    <category term="python" scheme="http://zhuyuezy.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>搭建私有Tor网络</title>
    <link href="http://zhuyuezy.github.io/2019/04/29/private-tor-network/"/>
    <id>http://zhuyuezy.github.io/2019/04/29/private-tor-network/</id>
    <published>2019-04-29T08:49:56.000Z</published>
    <updated>2020-09-27T09:02:21.580Z</updated>
    
    <content type="html"><![CDATA[<p>Tor网络由遍布世界各地的Tor节点组成，用户通过Tor发送的数据包在这些节点间加密传输，以达到匿名的目的。为了了解Tor的机制，我搭建了一个私有Tor网络，包含1个目录服务器，3个节点（都可作为出口节点），1个客户端，实现客户机通过私有Tor浏览网页。</p><p>（私有Tor网络匿名性显著下降，仅适用于实验学习）</p><a id="more"></a><hr><h1 id="实验网络拓扑"><a href="#实验网络拓扑" class="headerlink" title="实验网络拓扑"></a>实验网络拓扑</h1><p><img src="/images/post2019/privateTor.jpg" alt></p><p>Client：客户机<br>DA：Tor目录服务器<br>Guard、Middle、Exit：Tor中继或出口节点<br>以上所有机器搭载 Ubuntu 18.04</p><p><br></p><h1 id="安装Tor"><a href="#安装Tor" class="headerlink" title="安装Tor"></a>安装Tor</h1><p><code># sudo apt install tor</code></p><p>其他系统安装参考<a href="https://2019.www.torproject.org/docs/installguide.html.en" target="_blank" rel="noopener">官方安装指南</a>。</p><p><br></p><h1 id="配置目录服务器DA"><a href="#配置目录服务器DA" class="headerlink" title="配置目录服务器DA"></a>配置目录服务器DA</h1><p>Tor权威目录服务器（directory authority server）DA提供当前网络中的Tor节点信息，包括节点的地址、公钥等。当一个Tor节点接入网络时，首先要向DA获取活跃节点信息，再从中随机选择三个组成链路（circuit）。</p><p>首先，生成DA密钥和证书：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo -u debian-tor mkdir /var/lib/tor/keys</span><br><span class="line">sudo -u debian-tor tor-gencert --create-identity-key -m 12 -a 1.1.1.1:7000 \</span><br><span class="line">-i /var/lib/tor/keys/authority_identity_key \</span><br><span class="line">-s /var/lib/tor/keys/authority_signing_key \</span><br><span class="line">-c /var/lib/tor/keys/authority_certificate</span><br></pre></td></tr></table></figure><p>在ubuntu上使用用户名<code>debian-tor</code>，在其他系统如centOS上请根据实际更改为<code>/var/lib/tor</code>目录的所有者。</p><p>以上命令在<code>/var/lib/tor/keys</code>目录下为地址为<code>1.1.1.1</code>的DA生成的证书和私钥，并开放<code>7000</code>端口，其中</p><p><code>authority_identity_key</code>：主身份密钥，用于验证其签名密钥的有效性，应离线保存。</p><p><code>authority_signing_key</code>：签名密钥，用于签署投票和共识（consensuses）。</p><p><code>authority_certificate</code>：DA的证书，用于验证签名密钥。</p><p>接下来，生成节点密钥和指纹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -u debian-tor tor --list-fingerprint \</span><br><span class="line">--dirserver &quot;name 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; \</span><br><span class="line">--datadirectory /var/lib/tor/</span><br></pre></td></tr></table></figure><p>然后，编辑<code>/etc/tor/torrc</code>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">TestingTorNetwork 1</span><br><span class="line"></span><br><span class="line"># 这些配置是为了快速上线</span><br><span class="line"># 避开一些对稳定性的限制</span><br><span class="line">AssumeReachable 1</span><br><span class="line">TestingDirAuthVoteExit *</span><br><span class="line">TestingDirAuthVoteHSDir *</span><br><span class="line">TestingDirAuthVoteGuard *</span><br><span class="line">V3AuthNIntervalsValid 2</span><br><span class="line">TestingMinExitFlagThreshold 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DataDirectory /var/lib/tor</span><br><span class="line">RunAsDaemon 1</span><br><span class="line">ConnLimit 60</span><br><span class="line">Nickname DA</span><br><span class="line">ShutdownWaitLength 0</span><br><span class="line">PidFile /var/lib/tor/pid</span><br><span class="line">Log notice file /var/lib/tor/notice.log</span><br><span class="line">Log info file /var/lib/tor/info.log</span><br><span class="line">Log debug file /var/lib/tor/debug.log </span><br><span class="line">ProtocolWarnings 1</span><br><span class="line">SafeLogging 0</span><br><span class="line">DisableDebuggerAttachment 0</span><br><span class="line"></span><br><span class="line"># 指定自己的目录服务器</span><br><span class="line">DirAuthority DA orport=5000 no-v2 v3ident=finger1 1.1.1.1:7000 finger2</span><br><span class="line"></span><br><span class="line">SocksPort 0</span><br><span class="line"># OrPort监听Tor连接</span><br><span class="line">OrPort 5000</span><br><span class="line"># DirPort监听目录服务</span><br><span class="line">DirPort 7000</span><br><span class="line"></span><br><span class="line">NickName DA</span><br><span class="line">Address 1.1.1.1</span><br><span class="line"></span><br><span class="line"># 目录服务器</span><br><span class="line">AuthoritativeDirectory 1</span><br><span class="line">V3AuthoritativeDirectory 1</span><br><span class="line">ContactInfo auth0@test.test</span><br><span class="line"></span><br><span class="line"># 不作为出口</span><br><span class="line">ExitPolicy reject *:*</span><br><span class="line"></span><br><span class="line"># Vote + Dist必须小于1/2 * Interval</span><br><span class="line">TestingV3AuthInitialVotingInterval 300</span><br><span class="line">TestingV3AuthInitialVoteDelay 20</span><br><span class="line">TestingV3AuthInitialDistDelay 20</span><br><span class="line"></span><br><span class="line">V3AuthVotingInterval 300</span><br><span class="line">V3AuthVoteDelay 20</span><br><span class="line">V3AuthDistDelay 20</span><br></pre></td></tr></table></figure><p>其中finger1：</p><p><code>cat /var/lib/tor/keys/authority_certificate | grep fingerprint</code></p><p>finger2:</p><p> <code>/var/lib/tor/fingerprint</code></p><p>再启动tor服务就可以了。</p><h1 id="配置节点服务器"><a href="#配置节点服务器" class="headerlink" title="配置节点服务器"></a>配置节点服务器</h1><p>先停止Tor服务，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u debian-tor tor --list-fingerprint --orport 1 --dirserver &quot;x 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; --datadirectory /var/lib/tor/</span><br></pre></td></tr></table></figure><p>配置torrc:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">TestingTorNetwork 1</span><br><span class="line"></span><br><span class="line">AssumeReachable 1</span><br><span class="line">TestingDirAuthVoteExit *</span><br><span class="line">TestingDirAuthVoteHSDir *</span><br><span class="line">V3AuthNIntervalsValid 2</span><br><span class="line">TestingDirAuthVoteGuard *</span><br><span class="line">TestingMinExitFlagThreshold 0</span><br><span class="line"></span><br><span class="line">DataDirectory /var/lib/tor</span><br><span class="line">RunAsDaemon 1</span><br><span class="line">ConnLimit 60</span><br><span class="line">Nickname relay3</span><br><span class="line">ShutdownWaitLength 0</span><br><span class="line"></span><br><span class="line">PidFile /var/lib/tor/pid</span><br><span class="line">Log notice file /var/lib/tor/notice.log</span><br><span class="line">Log info file /var/lib/tor/info.log</span><br><span class="line">Log debug file /var/lib/tor/debug.log</span><br><span class="line"></span><br><span class="line">ProtocolWarnings 1</span><br><span class="line">SafeLogging 0</span><br><span class="line">DisableDebuggerAttachment 0</span><br><span class="line"></span><br><span class="line"># 指定目录服务器为DA</span><br><span class="line">DirAuthority DA orport=5000 no-v2 v3ident=finger1 1.1.1.1:7000 finger2</span><br><span class="line"></span><br><span class="line">SocksPort 0</span><br><span class="line">OrPort 5000</span><br><span class="line">ControlPort 9051</span><br><span class="line"></span><br><span class="line">NickName relayN</span><br><span class="line">Address 2.2.2.2</span><br><span class="line"></span><br><span class="line"># 作为出口节点</span><br><span class="line">ExitRelay 1</span><br></pre></td></tr></table></figure><p>重启Tor服务。</p><h1 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h1><p>同样，先停止Tor服务，然后生成指纹：</p><p><code>sudo -u debian-tor tor --list-fingerprint --orport 1 --dirserver &quot;x 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; --datadirectory /var/lib/tor/</code></p><p>配置Torrc文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TestingTorNetwork 1</span><br><span class="line"></span><br><span class="line">AssumeReachable 1</span><br><span class="line">TestingDirAuthVoteExit *</span><br><span class="line">TestingDirAuthVoteHSDir *</span><br><span class="line">V3AuthNIntervalsValid 2</span><br><span class="line">TestingDirAuthVoteGuard *</span><br><span class="line">TestingMinExitFlagThreshold 0</span><br><span class="line"></span><br><span class="line">DataDirectory /var/lib/tor</span><br><span class="line">RunAsDaemon 1</span><br><span class="line">ConnLimit 60</span><br><span class="line">Nickname relay3</span><br><span class="line">ShutdownWaitLength 0</span><br><span class="line"></span><br><span class="line">PidFile /var/lib/tor/pid</span><br><span class="line">Log notice file /var/lib/tor/notice.log</span><br><span class="line">Log info file /var/lib/tor/info.log</span><br><span class="line">Log debug file /var/lib/tor/debug.log</span><br><span class="line"></span><br><span class="line">ProtocolWarnings 1</span><br><span class="line">SafeLogging 0</span><br><span class="line">DisableDebuggerAttachment 0</span><br><span class="line"></span><br><span class="line"># 指定目录服务器为DA</span><br><span class="line">DirAuthority DA orport=5000 no-v2 v3ident=finger1 1.1.1.1:7000 finger2</span><br><span class="line"></span><br><span class="line"># 设置Socks端口</span><br><span class="line">SocksPort 9050</span><br><span class="line">ControlPort 9051</span><br><span class="line"></span><br><span class="line">NickName client</span><br><span class="line">Address x.x.x.x</span><br></pre></td></tr></table></figure><p>最后重启Tor服务。</p><h1 id="测试私有Tor网络"><a href="#测试私有Tor网络" class="headerlink" title="测试私有Tor网络"></a>测试私有Tor网络</h1><p>设置浏览器或系统代理为 127.0.0.1:9050 socks5，然后访问网页，使用Wireshark等抓包工具观察，或直接访问<a href="www.ipinfo.io">ipinfo.io</a>，就可以看到Tor网络的作用啦。</p><p>如果遇到问题，可以查看torrc文件中指定位置的notice.log、info.log等日志文件。</p><h1 id="可能遇到的部分问题"><a href="#可能遇到的部分问题" class="headerlink" title="可能遇到的部分问题"></a>可能遇到的部分问题</h1><h2 id="err-Error-initializing-keys-exiting"><a href="#err-Error-initializing-keys-exiting" class="headerlink" title="[err] Error initializing keys; exiting."></a>[err] Error initializing keys; exiting.</h2><p>在生成keys报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[err] Another Tor process has locked &quot;/var/lib/tor/keys/secret_id_key&quot;. Not writing any new keys.</span><br><span class="line">[err] Error initializing keys; exiting.</span><br></pre></td></tr></table></figure><p>这个问题非常好解决，先<code>service tor stop</code>就可以了。同样的解决方法还适用于报错部分文件被“lock”的情况。</p><h2 id="WARN-Failed-to-find-node-for-hop-0-of-our-path-Discarding-this-circuit"><a href="#WARN-Failed-to-find-node-for-hop-0-of-our-path-Discarding-this-circuit" class="headerlink" title="[WARN] Failed to find node for hop 0 of our path. Discarding this circuit."></a>[WARN] Failed to find node for hop 0 of our path. Discarding this circuit.</h2><p>如果notice.log中连续出现此告警，可以尝试校准系统时间。特别是目录服务器上。</p><p><code>sudo ntpdate -v pool.ntp.org</code></p><h2 id="Consensus-not-signed-by-sufficient-number-of-requested-authorities"><a href="#Consensus-not-signed-by-sufficient-number-of-requested-authorities" class="headerlink" title="Consensus not signed by sufficient number of requested authorities"></a>Consensus not signed by sufficient number of requested authorities</h2><p>或者<code>Not enough good signatures on networkstatus consensus</code> 之类的关于共识签名的错误。</p><p>我个人得到这个报错有两次：一次是torrc文件中，对目录服务器的fingerprint配置有误；另一次是我尝试让一个节点连接两台私有目录服务器，但这两台服务器彼此之前不知道，也无法为对方签署的共识签名。</p><h2 id="not-able-to-authenticate-relays"><a href="#not-able-to-authenticate-relays" class="headerlink" title="not able to authenticate relays"></a>not able to authenticate relays</h2><p>我的某一个客户端始终无法成功与Tor节点握手成功，查看info.log发现大量类似信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apr 23 19:52:29.000 [info] **choose_good_exit_server_general(): Chose exit server &apos;$1DDF03E9C34867C581F0DE8D6EAEC30A9188DB11~relay2 at 149.129.x.x&apos;</span><br><span class="line">Apr 23 19:52:29.000 [info] extend_info_from_node(): Not including the ed25519 ID for $1DDF03E9C34867C581F0DE8D6EAEC30A9188DB11~relay2 at 149.129.x.x, since it won&apos;t be able to authenticate it.**</span><br></pre></td></tr></table></figure><p>原因是这台客户端机器在国内，所以…</p><p>最后解决办法是用一个不在墙内的服务器S做Tor客户端，同时是WireGuard服务器。国内的机器通过WireGuard连接到S，然后由S转发流量到Tor网络。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://2019.www.torproject.org/docs/tor-manual.html.en" target="_blank" rel="noopener">Tor Manual</a></li><li><a href="https://github.com/torproject/chutney" target="_blank" rel="noopener">Chutney</a> （参考它生成的torrc文件）</li><li><a href="https://witestlab.poly.edu/blog/anonymous-routing-of-network-traffic-using-tor/" target="_blank" rel="noopener">Anonymous Routing of Network Traffic Using Tor</a></li><li><a href="http://ju.outofmemory.cn/entry/175626" target="_blank" rel="noopener">How to Setup Private Tor Network</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;Tor网络由遍布世界各地的Tor节点组成，用户通过Tor发送的数据包在这些节点间加密传输，以达到匿名的目的。为了了解Tor的机制，我搭建了一个私有Tor网络，包含1个目录服务器，3个节点（都可作为出口节点），1个客户端，实现客户机通过私有Tor浏览网页。&lt;/p&gt;
&lt;p&gt;（私有Tor网络匿名性显著下降，仅适用于实验学习）&lt;/p&gt;</summary>
    
    
    
    <category term="Tor" scheme="http://zhuyuezy.github.io/categories/Tor/"/>
    
    <category term="网络" scheme="http://zhuyuezy.github.io/categories/网络/"/>
    
    
    <category term="Tor" scheme="http://zhuyuezy.github.io/tags/Tor/"/>
    
    <category term="网络" scheme="http://zhuyuezy.github.io/tags/网络/"/>
    
    <category term="匿名" scheme="http://zhuyuezy.github.io/tags/匿名/"/>
    
  </entry>
  
  <entry>
    <title>ssh + iptables + redsocks实现ubuntu全局代理</title>
    <link href="http://zhuyuezy.github.io/2019/03/13/ssh+iptables+redsocks%E5%AE%9E%E7%8E%B0ubuntu%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/"/>
    <id>http://zhuyuezy.github.io/2019/03/13/ssh+iptables+redsocks%E5%AE%9E%E7%8E%B0ubuntu%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86/</id>
    <published>2019-03-13T13:37:08.000Z</published>
    <updated>2020-09-27T09:02:21.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>在两台搭载ubuntu的服务器A，B间搭一个跳板，实现A上所有TCP流量由B转发。</p><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>在服务器A上与B建立起SSH隧道，指定转发端口p，然后用iptables将所有TCP流量转发到redsocks的侦听端口，再由redsocks转到端口p发出。</p><a id="more"></a><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>SSH（Secure Shell）是一种加密网络传输协议，可在不安全的网络中提供安全传输。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>类Unix系统自带ssh命令，Windows下可用Putty等工具代替。</p><h2 id="SSH隧道"><a href="#SSH隧道" class="headerlink" title="SSH隧道"></a>SSH隧道</h2><p>ssh端口转发在两台主机之间搭建了一个数据传输的安全隧道，因此也被称为ssh隧道。ssh端口转发有三种模式：本地端口转发、远程端口转发、动态端口转发。具体内容可参考这篇<a href="https://cloud.tencent.com/developer/article/1335416" target="_blank" rel="noopener">玩转SSH端口转发</a>。</p><p>在这里使用SSH的动态端口转发，指定本地端口11223.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将A上经过11223端口的流量由B转发</span></span><br><span class="line">ssh -D localhost:11223 B_User@B_IP</span><br></pre></td></tr></table></figure><p>接下来就只需要想办法让A上所有TCP流量都由11223端口出去。</p><h1 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h1><p>iptables是用于配置Linux内核防火墙的命令行工具，它可以按规则检测、修改、转发、重定向和丢弃IPv4数据包。iptables规则主要由表和链组成，<a href="https://wiki.archlinux.org/index.php/Iptables_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">这里</a>)有详细介绍。</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>这里使用iptables把tcp流量全部转发到redsocks的侦听端口11111上（udp等也可以，我没有配置）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 在nat表上新建REDSOCKS链</span><br><span class="line">iptables -t nat -N REDSOCKS</span><br><span class="line"></span><br><span class="line"># 忽略服务器B地址</span><br><span class="line">iptables -t nat -A REDSOCKS -d B_IP -j RETURN </span><br><span class="line"></span><br><span class="line"># 忽略本地地址 </span><br><span class="line">iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN </span><br><span class="line">iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN </span><br><span class="line">iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN </span><br><span class="line">iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN </span><br><span class="line">iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN </span><br><span class="line">iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN </span><br><span class="line">iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN </span><br><span class="line">iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN</span><br><span class="line"></span><br><span class="line"># 其余tcp包都转发到redsocks端口</span><br><span class="line">iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 11111 </span><br><span class="line">iptables -t nat -A OUTPUT -p tcp -j REDSOCKS</span><br></pre></td></tr></table></figure><h1 id="redsocks"><a href="#redsocks" class="headerlink" title="redsocks"></a>redsocks</h1><p>redsocks是一个开源TCP重定向工具，它的github地址在<a href="https://github.com/darkk/redsocks" target="_blank" rel="noopener">这里</a>。</p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install redsocks</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service redsocks start</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>redsocks在ubuntu下的配置文件路径为<code>/etc/redsocks.conf</code>。</p><p>我的配置文件如下，只配置了tcp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">base &#123;</span><br><span class="line">// debug: connection progress &amp; client list on SIGUSR1</span><br><span class="line">log_debug = off;</span><br><span class="line"></span><br><span class="line">// info: start and end of client session</span><br><span class="line">log_info = on;</span><br><span class="line"></span><br><span class="line">/* possible `log&apos; values are:</span><br><span class="line"> *   stderr</span><br><span class="line"> *   &quot;file:/path/to/file&quot;</span><br><span class="line"> *   syslog:FACILITY  facility is any of &quot;daemon&quot;, &quot;local0&quot;...&quot;local7&quot;</span><br><span class="line"> */</span><br><span class="line">log = &quot;syslog:daemon&quot;;</span><br><span class="line"></span><br><span class="line">// detach from console</span><br><span class="line">daemon = on;</span><br><span class="line"></span><br><span class="line">/* Change uid, gid and root directory, these options require root</span><br><span class="line"> * privilegies on startup.</span><br><span class="line"> * Note, your chroot may requre /etc/localtime if you write log to syslog.</span><br><span class="line"> * Log is opened before chroot &amp; uid changing.</span><br><span class="line"> */</span><br><span class="line">user = redsocks;</span><br><span class="line">group = redsocks;</span><br><span class="line">// chroot = &quot;/var/chroot&quot;;</span><br><span class="line"></span><br><span class="line">/* possible `redirector&apos; values are:</span><br><span class="line"> *   iptables   - for Linux</span><br><span class="line"> *   ipf        - for FreeBSD</span><br><span class="line"> *   pf         - for OpenBSD</span><br><span class="line"> *   generic    - some generic redirector that MAY work</span><br><span class="line"> */</span><br><span class="line">redirector = iptables;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redsocks &#123;</span><br><span class="line">/* `local_ip&apos; defaults to 127.0.0.1 for security reasons,</span><br><span class="line"> * use 0.0.0.0 if you want to listen on every interface.</span><br><span class="line"> * `local_*&apos; are used as port to redirect to.</span><br><span class="line"> * 本地redsocks要监听的地址和端口</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">local_ip = 127.0.0.1;</span><br><span class="line">local_port = 11111;</span><br><span class="line"></span><br><span class="line">// `ip&apos; and `port&apos; are IP and tcp-port of proxy-server</span><br><span class="line">// You can also use hostname instead of IP, only one (random)</span><br><span class="line">// address of multihomed host will be used.</span><br><span class="line">// socks地址和端口(ssh创建的socks隧道)</span><br><span class="line">ip = 127.0.0.1;</span><br><span class="line">port = 11223;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// known types: socks4, socks5, http-connect, http-relay</span><br><span class="line">type = socks5;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一键脚本"><a href="#一键脚本" class="headerlink" title="一键脚本"></a>一键脚本</h1><p>一键才是最棒的。这个脚本参考了liruqi的博客文章 <a href="https://liruqi.wordpress.com/2011/04/07/redsocks-for-global-proxy/" target="_blank" rel="noopener">使用 redsocks 作强制的系统全局代理</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line"></span><br><span class="line">start_ssh() </span><br><span class="line">&#123; </span><br><span class="line">    echo &quot;Start SSH Tunnel : &quot; </span><br><span class="line">    # redsocks官方不建议使用此工具转发tor流量，但我emm</span><br><span class="line">    torify ssh -Nf -D 11223 user@b_ip</span><br><span class="line">    echo &quot;SSH Tunnel Started.&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop_ssh() </span><br><span class="line">&#123; </span><br><span class="line"># 这里写得很不好，不过可以用</span><br><span class="line">    SSHID=$(ps -ef|grep 54321|awk &apos;&#123;print $2&#125;&apos;)</span><br><span class="line">    SSHID=$SSHID |awk &apos;&#123;print $1&#125;&apos;</span><br><span class="line">    echo $SSHID</span><br><span class="line">    kill -9 $&#123;SSHID&#125;</span><br><span class="line">    echo &quot;SSH Tunnel Daemon Stoped.&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in </span><br><span class="line">  start) </span><br><span class="line">    start_ssh </span><br><span class="line">    service redsocks start</span><br><span class="line"></span><br><span class="line">    # 清空nat表，添加新链 </span><br><span class="line">    iptables -t nat -F</span><br><span class="line">    iptables -t nat -N REDSOCKS</span><br><span class="line"></span><br><span class="line">    # 忽略本地地址</span><br><span class="line">    iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN </span><br><span class="line">    iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN </span><br><span class="line">    iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN </span><br><span class="line">    iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN </span><br><span class="line">    iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN </span><br><span class="line">    iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN </span><br><span class="line">    iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN </span><br><span class="line">    iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN</span><br><span class="line"></span><br><span class="line">    # Anything else should be redirected to port 11111</span><br><span class="line">    iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 11111</span><br><span class="line">    # Any tcp connection should be redirected. </span><br><span class="line">    iptables -t nat -A OUTPUT -p tcp -j REDSOCKS </span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  stop) </span><br><span class="line">    stop_ssh </span><br><span class="line">    killall -9 redsocks </span><br><span class="line">    </span><br><span class="line">    # 删除iptables规则 </span><br><span class="line">    iptables -t nat -F OUTPUT </span><br><span class="line">    iptables -t nat -F REDSOCKS </span><br><span class="line">    iptables -t nat -X REDSOCKS </span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  start_ssh) </span><br><span class="line">    start_ssh </span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">  stop_ssh) </span><br><span class="line">    stop_ssh </span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *) </span><br><span class="line">    echo &quot;Usage: redsocks start|stop|start_ssh|stop_ssh&quot; &gt;&amp;2 </span><br><span class="line">    exit 3 </span><br><span class="line">    ;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>1、建立使用tor的ssh：在两端安装并启动tor服务后，使用封装好的torify命令发起ssh请求即可。参考<a href="https://medium.com/@tzhenghao/how-to-ssh-over-tor-onion-service-c6d06194147" target="_blank" rel="noopener">SSH over Tor</a>。</p><p>2、一个未解疑问：为什么我直接使用iptables转发到ssh隧道端口就不行呢…</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;在两台搭载ubuntu的服务器A，B间搭一个跳板，实现A上所有TCP流量由B转发。&lt;/p&gt;
&lt;h1 id=&quot;实现方法&quot;&gt;&lt;a href=&quot;#实现方法&quot; class=&quot;headerlink&quot; title=&quot;实现方法&quot;&gt;&lt;/a&gt;实现方法&lt;/h1&gt;&lt;p&gt;在服务器A上与B建立起SSH隧道，指定转发端口p，然后用iptables将所有TCP流量转发到redsocks的侦听端口，再由redsocks转到端口p发出。&lt;/p&gt;</summary>
    
    
    
    <category term="linux" scheme="http://zhuyuezy.github.io/categories/linux/"/>
    
    <category term="网络" scheme="http://zhuyuezy.github.io/categories/网络/"/>
    
    
    <category term="网络" scheme="http://zhuyuezy.github.io/tags/网络/"/>
    
    <category term="linux" scheme="http://zhuyuezy.github.io/tags/linux/"/>
    
    <category term="代理" scheme="http://zhuyuezy.github.io/tags/代理/"/>
    
  </entry>
  
  <entry>
    <title>githubpages + hexo搭建博客</title>
    <link href="http://zhuyuezy.github.io/2019/03/12/build-blog-with-hexo/"/>
    <id>http://zhuyuezy.github.io/2019/03/12/build-blog-with-hexo/</id>
    <published>2019-03-12T09:09:00.000Z</published>
    <updated>2020-09-28T01:49:07.930Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下在macOS上利用hexo和GitHub搭建本博客的过程。hexo的<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">中文官方指南</a>在这里。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p> 你要有个Github账号和一个Gitpage仓库。</p><a id="more"></a><h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><h2 id="安装Node-js-amp-Git"><a href="#安装Node-js-amp-Git" class="headerlink" title="安装Node.js &amp; Git"></a>安装Node.js &amp; Git</h2><p> <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p> <a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></p><p> 有博客说hexo编译会依赖Xcode，Xcode在App Store下载即可。</p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><p> 在你想要作为博客目录的目录下，打开终端：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="安装hexo-server"><a href="#安装hexo-server" class="headerlink" title="安装hexo server"></a>安装hexo server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install hexo-server</span><br></pre></td></tr></table></figure><p> 到这里hexo生成页面的所有组件就安装完啦！<br> 可以先看看默认的页面什么样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g (/generate)</span><br><span class="line">hexo s (/server)</span><br></pre></td></tr></table></figure><p> 看到 Hexo is running at <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>.<br> 就可以看看默认的页面啦。</p><p>#基本配置</p><h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><p> 在Hexo安装目录里找到_config.yml文件，打开，修改最后面的deploy段为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line"> type: git </span><br><span class="line"> repo: https://github.com/你的用户名/你的用户名.github.io.git </span><br><span class="line"> branch: master</span><br></pre></td></tr></table></figure><p>  然后 hexo d (/deploy)<br>  就部署到你的gitpage啦。</p><h1 id="hexo基本操作"><a href="#hexo基本操作" class="headerlink" title="hexo基本操作"></a>hexo基本操作</h1><p>写文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot;</span><br></pre></td></tr></table></figure><p>生成静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>本地预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>部署</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>这里有一个可能忘记的点：在部署之前需要安装hexo-deployer-git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p>清除缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>详细参见 <a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">指令 | hexo</a>。 </p><h1 id="个性化"><a href="#个性化" class="headerlink" title="个性化"></a>个性化</h1><p> 在<a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题列表</a>上找到心仪主题，clone到博客目录下的themes目录，再更改_config.yml文件的theme参数为想更换的主题名称即可。注意此处的主题名称是存放主题的文件夹的名称。</p><p> 参考了这两篇博客：</p><p> <a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">hexo的next主题个性化配置教程</a></p><p> <a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">HEXO-NEXT主题个性化配置</a></p><h1 id="源码自动备份"><a href="#源码自动备份" class="headerlink" title="源码自动备份"></a>源码自动备份</h1><p> 参考这两篇博客。</p><p> <a href="https://notes.doublemine.me/2015-04-06-%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html" target="_blank" rel="noopener">备份Hexo博客源文件</a></p><p> <a href="https://notes.doublemine.me/2015-07-06-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html" target="_blank" rel="noopener">自动备份Hexo博客源文件</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下在macOS上利用hexo和GitHub搭建本博客的过程。hexo的&lt;a href=&quot;https://hexo.io/zh-cn/docs/setup.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文官方指南&lt;/a&gt;在这里。&lt;/p&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;p&gt; 你要有个Github账号和一个Gitpage仓库。&lt;/p&gt;</summary>
    
    
    
    <category term="其他" scheme="http://zhuyuezy.github.io/categories/其他/"/>
    
    
    <category term="hexo" scheme="http://zhuyuezy.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hook之 Method Swizzling</title>
    <link href="http://zhuyuezy.github.io/2018/05/18/methodSwizzling/"/>
    <id>http://zhuyuezy.github.io/2018/05/18/methodSwizzling/</id>
    <published>2018-05-18T08:32:00.000Z</published>
    <updated>2020-09-27T09:02:21.579Z</updated>
    
    <content type="html"><![CDATA[<p>Method Swizzling利用了Objective-C的runtime特性，使得我们能动态替换方法的实现，实现hook。<br><a id="more"></a></p><h1 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h1><p>从敲下<code>NSlog(@&quot;hello world!&quot;)</code>开始，就不断看到runtime这个词。对于之前没接触过动态语言的学习者来说，runtime听起来陌生又晦涩。</p><p>Objective-C不同于C语言，它是一门动态语言，这就意味着它将C语言等静态语言在编译和链接时所做的一些工作留到了运行时再处理。比如，在C语言中，编译时就可以确定真正调用哪些函数；而Objective-C并不能在编译时确定，只有在运行时才会由名称找到对应方法。</p><p>因为这种特性，Objective-C需要一种机制在运行时来处理编译后的代码，这种机制就是runtime。Runtime从实质来讲，就是一套用C语言和汇编写成的底层API，用于处理编译后的代码。</p><h1 id="method"><a href="#method" class="headerlink" title="method"></a>method</h1><p><img src="/images/methodSwizzling/1.png" alt="methodStruct" title="method结构体"><br>method_name 表示的是方法的名称，用于唯一标识某个方法；<br>method_types 表示的是方法的返回值和参数类型；<br>method_imp 是一个函数指针，指向方法的实现。<br>方法的名称 name 和方法的实现 imp 是一一对应的。而且可以发现方法的名称和参数类型是分离的。<br>在我们调用一个方法时</p><pre><code>[someObject messageName:paremeter]</code></pre><p>在runtime底层会转换成</p><pre><code>Objc_msgSend(someObject, @selector(messageName), paremeter)</code></pre><p>调用方法其实是向一个对象发送消息，而查找方法实现的唯一依据是selector后接的方法名称。所以，利用这一特性，我们就可以实现在运行时更改selector对应的方法实现，也就实现了HOOK。</p><h1 id="method-swizzling"><a href="#method-swizzling" class="headerlink" title="method swizzling"></a>method swizzling</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/images/methodSwizzling/2.png" alt="methodIMP" title="类和方法列表"><br><img src="/images/methodSwizzling/3.png" alt="changeIMP" title="替换"></p><blockquote><p>图源:念茜</p></blockquote><p>每个类都维护着一个方法列表，里面存放着selector的名字与方法实现间的映射关系。Method Swizzling就是改换了这种对应关系。</p><p>可以调用三种方法来实现method swizzling：<br><code>method_exchangeImplementations</code> 交换2个方法中的IMP（IMPlication）；<br><code>class_replaceMethod</code> 修改类；<br>利用 <code>method_setImplementation</code>直接设置某个方法的IMP。<br>这些方法的声明都写在<code>runtime.h</code>中。</p><h2 id="1-method-exchangeImplementations"><a href="#1-method-exchangeImplementations" class="headerlink" title="1.method_exchangeImplementations"></a>1.method_exchangeImplementations</h2><p> <img src="/images/methodSwizzling/4.png" alt="1"></p><p><code>method_exchangeImplementations</code>通过交换两个方法的IMP实现hook的，通过<br><code>method_exchangeImplementations(A_Method, B_Method);</code><br>可以实现如下图的交换。<br><img src="/images/methodSwizzling/5.png" alt="1"></p><h2 id="2-method-setImplementation"><a href="#2-method-setImplementation" class="headerlink" title="2.method_setImplementation"></a>2.method_setImplementation</h2><p> <img src="/images/methodSwizzling/method_setImplementation.png" alt="1"></p><p><code>method_setImplementation</code>直接设置更改某个方法的IMP。<br>如下图，假设有方法A，我们想要把它的实现替换为方法B的实现，但又不想改变方法B的实现，就可以使用<code>method_setImplementation</code>，直接把A的IMP设置为B的IMP。</p><p><img src="/images/methodSwizzling/6.png" alt="1"></p><h2 id="3-class-replaceMethod"><a href="#3-class-replaceMethod" class="headerlink" title="3.class_replaceMethod"></a>3.class_replaceMethod</h2><p> <img src="/images/methodSwizzling/class_rep.png" alt="1"></p><p><code>class_replaceMethod</code>其实相当于<code>class_addMethod</code>和<code>method_setImplementation</code>的一个结合。</p><p>当调用<br><code>class_replaceMethod(cls, name,  imp,  types)</code><br>时，将把属于<code>cls</code>类的<code>name</code>方法实现指向<code>imp</code>。<br>如果<code>cls</code>类原本没有<code>name</code>方法，就相当于调用<code>class_addMethod</code>给<code>cls</code>类增添了一个方法及其实现，这个方法的返回类型由<code>types</code>给定。<br>如果<code>cls</code>类原本就有<code>name</code>方法，就相当于调用<code>method_setImplementation</code>更改了<code>name</code>方法的实现为<code>imp</code>，返回类型由替换的实现<code>imp</code>决定，给定<code>types</code>将被忽略。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">Objective-C的hook方案（一）: Method Swizzling</a><br><a href="https://amywushu.github.io/2017/03/01/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-Hook-%E5%8E%9F%E7%90%86%E4%B9%8B-Method-Swizzling.html" target="_blank" rel="noopener">Hook 原理之 Method Swizzling</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Method Swizzling利用了Objective-C的runtime特性，使得我们能动态替换方法的实现，实现hook。&lt;br&gt;</summary>
    
    
    
    <category term="objective-c基础" scheme="http://zhuyuezy.github.io/categories/objective-c基础/"/>
    
    
    <category term="Objective-C" scheme="http://zhuyuezy.github.io/tags/Objective-C/"/>
    
    <category term="hook" scheme="http://zhuyuezy.github.io/tags/hook/"/>
    
  </entry>
  
</feed>
