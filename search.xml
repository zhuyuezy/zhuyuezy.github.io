<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跑路日记]]></title>
    <url>%2F2021%2F12%2F03%2F%E8%B7%91%E8%B7%AF%E6%97%A5%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这是一篇没有营养的跑路日记，记录我从决定跑路到最终成功跑路（希望）的过程。 2021.12.3 在半个月无休、近一周无正常睡眠之后，我决定跑路。 毕业后入职现单位已经近一年五个月，从最初的好奇、信心满满到现在的疲惫、迷茫。工作累不是问题，又累又没希望最为致命。转头看看部门老员工，再干几年还是一样，无休止的加班，难以得到的正常节假日，永远的7x24待命。 我得跑。 再也不要做运维了，我要睡觉。 盘点一下现存技能，sql经常使用还算熟练，有时候写点python脚本方便自己工作，oc和c已经不记得了。已跟男友约好一天不学习转他100，加班到深夜除外，希望不要变成他月收+3000。就从把python再次学起来开始吧，争取年后能成功跑路。 ！！跑路！！我要睡觉！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python 3 读取文件错误：UnicodeDecodeError]]></title>
    <url>%2F2019%2F11%2F14%2FPython3-UnicodeDecodeError%2F</url>
    <content type="text"><![CDATA[今天在Python 3中读取kaggle 2015提供的某.asm文件时，报错UnicodeDecodeError:&#39;utf-8&#39; codec can&#39;t decode byte 0xa0 in position 6605: invalid start byte. 导致这个报错的原因是：该文件的编码方式为ASCII text, with CRLF line terminators，而不是utf-8。 解决方法多种： 1、改用Python 2，因为Python 2默认以字节流的方式读取文件; 2、基于与1同样的原因，可以在Python 3中以&#39;rb&#39;方式读取； 3、也可使用sublime等文本编辑软件，以utf-8编码重新存储该文件，再读取。 以上就是这个error的解决方法啦 ٩(ˊᗜˋ*)و]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>error</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建私有Tor网络]]></title>
    <url>%2F2019%2F04%2F29%2Fprivate-tor-network%2F</url>
    <content type="text"><![CDATA[Tor网络由遍布世界各地的Tor节点组成，用户通过Tor发送的数据包在这些节点间加密传输，以达到匿名的目的。为了了解Tor的机制，我搭建了一个私有Tor网络，包含1个目录服务器，3个节点（都可作为出口节点），1个客户端，实现客户机通过私有Tor浏览网页。 （私有Tor网络匿名性显著下降，仅适用于实验学习） 实验网络拓扑 Client：客户机DA：Tor目录服务器Guard、Middle、Exit：Tor中继或出口节点以上所有机器搭载 Ubuntu 18.04 安装Tor# sudo apt install tor 其他系统安装参考官方安装指南。 配置目录服务器DATor权威目录服务器（directory authority server）DA提供当前网络中的Tor节点信息，包括节点的地址、公钥等。当一个Tor节点接入网络时，首先要向DA获取活跃节点信息，再从中随机选择三个组成链路（circuit）。 首先，生成DA密钥和证书： 12345sudo -u debian-tor mkdir /var/lib/tor/keyssudo -u debian-tor tor-gencert --create-identity-key -m 12 -a 1.1.1.1:7000 \-i /var/lib/tor/keys/authority_identity_key \-s /var/lib/tor/keys/authority_signing_key \-c /var/lib/tor/keys/authority_certificate 在ubuntu上使用用户名debian-tor，在其他系统如centOS上请根据实际更改为/var/lib/tor目录的所有者。 以上命令在/var/lib/tor/keys目录下为地址为1.1.1.1的DA生成的证书和私钥，并开放7000端口，其中 authority_identity_key：主身份密钥，用于验证其签名密钥的有效性，应离线保存。 authority_signing_key：签名密钥，用于签署投票和共识（consensuses）。 authority_certificate：DA的证书，用于验证签名密钥。 接下来，生成节点密钥和指纹： 123sudo -u debian-tor tor --list-fingerprint \--dirserver &quot;name 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; \--datadirectory /var/lib/tor/ 然后，编辑/etc/tor/torrc文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253TestingTorNetwork 1# 这些配置是为了快速上线# 避开一些对稳定性的限制AssumeReachable 1TestingDirAuthVoteExit *TestingDirAuthVoteHSDir *TestingDirAuthVoteGuard *V3AuthNIntervalsValid 2TestingMinExitFlagThreshold 0DataDirectory /var/lib/torRunAsDaemon 1ConnLimit 60Nickname DAShutdownWaitLength 0PidFile /var/lib/tor/pidLog notice file /var/lib/tor/notice.logLog info file /var/lib/tor/info.logLog debug file /var/lib/tor/debug.log ProtocolWarnings 1SafeLogging 0DisableDebuggerAttachment 0# 指定自己的目录服务器DirAuthority DA orport=5000 no-v2 v3ident=finger1 1.1.1.1:7000 finger2SocksPort 0# OrPort监听Tor连接OrPort 5000# DirPort监听目录服务DirPort 7000NickName DAAddress 1.1.1.1# 目录服务器AuthoritativeDirectory 1V3AuthoritativeDirectory 1ContactInfo auth0@test.test# 不作为出口ExitPolicy reject *:*# Vote + Dist必须小于1/2 * IntervalTestingV3AuthInitialVotingInterval 300TestingV3AuthInitialVoteDelay 20TestingV3AuthInitialDistDelay 20V3AuthVotingInterval 300V3AuthVoteDelay 20V3AuthDistDelay 20 其中finger1： cat /var/lib/tor/keys/authority_certificate | grep fingerprint finger2: /var/lib/tor/fingerprint 再启动tor服务就可以了。 配置节点服务器先停止Tor服务，然后 1sudo -u debian-tor tor --list-fingerprint --orport 1 --dirserver &quot;x 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; --datadirectory /var/lib/tor/ 配置torrc: 123456789101112131415161718192021222324252627282930313233343536TestingTorNetwork 1AssumeReachable 1TestingDirAuthVoteExit *TestingDirAuthVoteHSDir *V3AuthNIntervalsValid 2TestingDirAuthVoteGuard *TestingMinExitFlagThreshold 0DataDirectory /var/lib/torRunAsDaemon 1ConnLimit 60Nickname relay3ShutdownWaitLength 0PidFile /var/lib/tor/pidLog notice file /var/lib/tor/notice.logLog info file /var/lib/tor/info.logLog debug file /var/lib/tor/debug.logProtocolWarnings 1SafeLogging 0DisableDebuggerAttachment 0# 指定目录服务器为DADirAuthority DA orport=5000 no-v2 v3ident=finger1 1.1.1.1:7000 finger2SocksPort 0OrPort 5000ControlPort 9051NickName relayNAddress 2.2.2.2# 作为出口节点ExitRelay 1 重启Tor服务。 配置客户端同样，先停止Tor服务，然后生成指纹： sudo -u debian-tor tor --list-fingerprint --orport 1 --dirserver &quot;x 127.0.0.1:1 ffffffffffffffffffffffffffffffffffffffff&quot; --datadirectory /var/lib/tor/ 配置Torrc文件： 12345678910111213141516171819202122232425262728293031323334TestingTorNetwork 1AssumeReachable 1TestingDirAuthVoteExit *TestingDirAuthVoteHSDir *V3AuthNIntervalsValid 2TestingDirAuthVoteGuard *TestingMinExitFlagThreshold 0DataDirectory /var/lib/torRunAsDaemon 1ConnLimit 60Nickname relay3ShutdownWaitLength 0PidFile /var/lib/tor/pidLog notice file /var/lib/tor/notice.logLog info file /var/lib/tor/info.logLog debug file /var/lib/tor/debug.logProtocolWarnings 1SafeLogging 0DisableDebuggerAttachment 0# 指定目录服务器为DADirAuthority DA orport=5000 no-v2 v3ident=finger1 1.1.1.1:7000 finger2# 设置Socks端口SocksPort 9050ControlPort 9051NickName clientAddress x.x.x.x 最后重启Tor服务。 测试私有Tor网络设置浏览器或系统代理为 127.0.0.1:9050 socks5，然后访问网页，使用Wireshark等抓包工具观察，或直接访问ipinfo.io，就可以看到Tor网络的作用啦。 如果遇到问题，可以查看torrc文件中指定位置的notice.log、info.log等日志文件。 可能遇到的部分问题[err] Error initializing keys; exiting.在生成keys报错： 12[err] Another Tor process has locked &quot;/var/lib/tor/keys/secret_id_key&quot;. Not writing any new keys.[err] Error initializing keys; exiting. 这个问题非常好解决，先service tor stop就可以了。同样的解决方法还适用于报错部分文件被“lock”的情况。 [WARN] Failed to find node for hop 0 of our path. Discarding this circuit.如果notice.log中连续出现此告警，可以尝试校准系统时间。特别是目录服务器上。 sudo ntpdate -v pool.ntp.org Consensus not signed by sufficient number of requested authorities或者Not enough good signatures on networkstatus consensus 之类的关于共识签名的错误。 我个人得到这个报错有两次：一次是torrc文件中，对目录服务器的fingerprint配置有误；另一次是我尝试让一个节点连接两台私有目录服务器，但这两台服务器彼此之前不知道，也无法为对方签署的共识签名。 not able to authenticate relays我的某一个客户端始终无法成功与Tor节点握手成功，查看info.log发现大量类似信息： 12Apr 23 19:52:29.000 [info] **choose_good_exit_server_general(): Chose exit server &apos;$1DDF03E9C34867C581F0DE8D6EAEC30A9188DB11~relay2 at 149.129.x.x&apos;Apr 23 19:52:29.000 [info] extend_info_from_node(): Not including the ed25519 ID for $1DDF03E9C34867C581F0DE8D6EAEC30A9188DB11~relay2 at 149.129.x.x, since it won&apos;t be able to authenticate it.** 原因是这台客户端机器在国内，所以… 最后解决办法是用一个不在墙内的服务器S做Tor客户端，同时是WireGuard服务器。国内的机器通过WireGuard连接到S，然后由S转发流量到Tor网络。 参考 Tor Manual Chutney （参考它生成的torrc文件） Anonymous Routing of Network Traffic Using Tor How to Setup Private Tor Network]]></content>
      <categories>
        <category>Tor</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Tor</tag>
        <tag>网络</tag>
        <tag>匿名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh + iptables + redsocks实现ubuntu全局代理]]></title>
    <url>%2F2019%2F03%2F13%2Fssh%2Biptables%2Bredsocks%E5%AE%9E%E7%8E%B0ubuntu%E5%85%A8%E5%B1%80%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[需求在两台搭载ubuntu的服务器A，B间搭一个跳板，实现A上所有TCP流量由B转发。 实现方法在服务器A上与B建立起SSH隧道，指定转发端口p，然后用iptables将所有TCP流量转发到redsocks的侦听端口，再由redsocks转到端口p发出。 SSHSSH（Secure Shell）是一种加密网络传输协议，可在不安全的网络中提供安全传输。 安装类Unix系统自带ssh命令，Windows下可用Putty等工具代替。 SSH隧道ssh端口转发在两台主机之间搭建了一个数据传输的安全隧道，因此也被称为ssh隧道。ssh端口转发有三种模式：本地端口转发、远程端口转发、动态端口转发。具体内容可参考这篇玩转SSH端口转发。 在这里使用SSH的动态端口转发，指定本地端口11223. 12# 将A上经过11223端口的流量由B转发ssh -D localhost:11223 B_User@B_IP 接下来就只需要想办法让A上所有TCP流量都由11223端口出去。 iptablesiptables是用于配置Linux内核防火墙的命令行工具，它可以按规则检测、修改、转发、重定向和丢弃IPv4数据包。iptables规则主要由表和链组成，这里)有详细介绍。 规则这里使用iptables把tcp流量全部转发到redsocks的侦听端口11111上（udp等也可以，我没有配置）。 12345678910111213141516171819# 在nat表上新建REDSOCKS链iptables -t nat -N REDSOCKS# 忽略服务器B地址iptables -t nat -A REDSOCKS -d B_IP -j RETURN # 忽略本地地址 iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN# 其余tcp包都转发到redsocks端口iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 11111 iptables -t nat -A OUTPUT -p tcp -j REDSOCKS redsocksredsocks是一个开源TCP重定向工具，它的github地址在这里。 安装12sudo apt-get updatesudo apt-get install redsocks 启动服务1service redsocks start 配置redsocks在ubuntu下的配置文件路径为/etc/redsocks.conf。 我的配置文件如下，只配置了tcp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657base &#123; // debug: connection progress &amp; client list on SIGUSR1 log_debug = off; // info: start and end of client session log_info = on; /* possible `log&apos; values are: * stderr * &quot;file:/path/to/file&quot; * syslog:FACILITY facility is any of &quot;daemon&quot;, &quot;local0&quot;...&quot;local7&quot; */ log = &quot;syslog:daemon&quot;; // detach from console daemon = on; /* Change uid, gid and root directory, these options require root * privilegies on startup. * Note, your chroot may requre /etc/localtime if you write log to syslog. * Log is opened before chroot &amp; uid changing. */ user = redsocks; group = redsocks; // chroot = &quot;/var/chroot&quot;; /* possible `redirector&apos; values are: * iptables - for Linux * ipf - for FreeBSD * pf - for OpenBSD * generic - some generic redirector that MAY work */ redirector = iptables;&#125;redsocks &#123; /* `local_ip&apos; defaults to 127.0.0.1 for security reasons, * use 0.0.0.0 if you want to listen on every interface. * `local_*&apos; are used as port to redirect to. * 本地redsocks要监听的地址和端口 */ local_ip = 127.0.0.1; local_port = 11111; // `ip&apos; and `port&apos; are IP and tcp-port of proxy-server // You can also use hostname instead of IP, only one (random) // address of multihomed host will be used. // socks地址和端口(ssh创建的socks隧道) ip = 127.0.0.1; port = 11223; // known types: socks4, socks5, http-connect, http-relay type = socks5;&#125; 一键脚本一键才是最棒的。这个脚本参考了liruqi的博客文章 使用 redsocks 作强制的系统全局代理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#! /bin/bashstart_ssh() &#123; echo &quot;Start SSH Tunnel : &quot; # redsocks官方不建议使用此工具转发tor流量，但我emm torify ssh -Nf -D 11223 user@b_ip echo &quot;SSH Tunnel Started.&quot; &#125;stop_ssh() &#123; # 这里写得很不好，不过可以用 SSHID=$(ps -ef|grep 54321|awk &apos;&#123;print $2&#125;&apos;) SSHID=$SSHID |awk &apos;&#123;print $1&#125;&apos; echo $SSHID kill -9 $&#123;SSHID&#125; echo &quot;SSH Tunnel Daemon Stoped.&quot; &#125;case &quot;$1&quot; in start) start_ssh service redsocks start # 清空nat表，添加新链 iptables -t nat -F iptables -t nat -N REDSOCKS # 忽略本地地址 iptables -t nat -A REDSOCKS -d 0.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN iptables -t nat -A REDSOCKS -d 224.0.0.0/4 -j RETURN iptables -t nat -A REDSOCKS -d 240.0.0.0/4 -j RETURN # Anything else should be redirected to port 11111 iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 11111 # Any tcp connection should be redirected. iptables -t nat -A OUTPUT -p tcp -j REDSOCKS ;; stop) stop_ssh killall -9 redsocks # 删除iptables规则 iptables -t nat -F OUTPUT iptables -t nat -F REDSOCKS iptables -t nat -X REDSOCKS ;; start_ssh) start_ssh ;; stop_ssh) stop_ssh ;; *) echo &quot;Usage: redsocks start|stop|start_ssh|stop_ssh&quot; &gt;&amp;2 exit 3 ;; esac 其他1、建立使用tor的ssh：在两端安装并启动tor服务后，使用封装好的torify命令发起ssh请求即可。参考SSH over Tor。 2、一个未解疑问：为什么我直接使用iptables转发到ssh隧道端口就不行呢…]]></content>
      <categories>
        <category>linux</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>linux</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[githubpages + hexo搭建博客]]></title>
    <url>%2F2019%2F03%2F12%2Fbuild-blog-with-hexo%2F</url>
    <content type="text"><![CDATA[记录一下在macOS上利用hexo和GitHub搭建本博客的过程。hexo的中文官方指南在这里。 准备 你要有个Github账号和一个Gitpage仓库。 安装：安装Node.js &amp; Git https://nodejs.org/en/ https://git-scm.com/ 有博客说hexo编译会依赖Xcode，Xcode在App Store下载即可。 安装Hexo1sudo npm install -g hexo-cli 初始化Hexo 在你想要作为博客目录的目录下，打开终端： 12hexo initnpm install 安装hexo server1sudo npm install hexo-server 到这里hexo生成页面的所有组件就安装完啦！ 可以先看看默认的页面什么样： 12hexo g (/generate)hexo s (/server) 看到 Hexo is running at http://localhost:4000/. 就可以看看默认的页面啦。 #基本配置 关联Github 在Hexo安装目录里找到_config.yml文件，打开，修改最后面的deploy段为： 1234deploy: type: git repo: https://github.com/你的用户名/你的用户名.github.io.git branch: master 然后 hexo d (/deploy) 就部署到你的gitpage啦。 hexo基本操作写文章 1hexo new &quot;postName&quot; 生成静态页面 1hexo g 本地预览 1hexo s 部署 1hexo d 这里有一个可能忘记的点：在部署之前需要安装hexo-deployer-git。 1npm install --save hexo-deployer-git 清除缓存 1hexo clean 详细参见 指令 | hexo。 个性化 在主题列表上找到心仪主题，clone到博客目录下的themes目录，再更改_config.yml文件的theme参数为想更换的主题名称即可。注意此处的主题名称是存放主题的文件夹的名称。 参考了这两篇博客： hexo的next主题个性化配置教程 HEXO-NEXT主题个性化配置 源码自动备份 参考这两篇博客。 备份Hexo博客源文件 自动备份Hexo博客源文件]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hook之 Method Swizzling]]></title>
    <url>%2F2018%2F05%2F18%2FmethodSwizzling%2F</url>
    <content type="text"><![CDATA[Method Swizzling利用了Objective-C的runtime特性，使得我们能动态替换方法的实现，实现hook。 runtime从敲下NSlog(@&quot;hello world!&quot;)开始，就不断看到runtime这个词。对于之前没接触过动态语言的学习者来说，runtime听起来陌生又晦涩。 Objective-C不同于C语言，它是一门动态语言，这就意味着它将C语言等静态语言在编译和链接时所做的一些工作留到了运行时再处理。比如，在C语言中，编译时就可以确定真正调用哪些函数；而Objective-C并不能在编译时确定，只有在运行时才会由名称找到对应方法。 因为这种特性，Objective-C需要一种机制在运行时来处理编译后的代码，这种机制就是runtime。Runtime从实质来讲，就是一套用C语言和汇编写成的底层API，用于处理编译后的代码。 methodmethod_name 表示的是方法的名称，用于唯一标识某个方法；method_types 表示的是方法的返回值和参数类型；method_imp 是一个函数指针，指向方法的实现。方法的名称 name 和方法的实现 imp 是一一对应的。而且可以发现方法的名称和参数类型是分离的。在我们调用一个方法时 [someObject messageName:paremeter] 在runtime底层会转换成 Objc_msgSend(someObject, @selector(messageName), paremeter) 调用方法其实是向一个对象发送消息，而查找方法实现的唯一依据是selector后接的方法名称。所以，利用这一特性，我们就可以实现在运行时更改selector对应的方法实现，也就实现了HOOK。 method swizzling原理 图源:念茜 每个类都维护着一个方法列表，里面存放着selector的名字与方法实现间的映射关系。Method Swizzling就是改换了这种对应关系。 可以调用三种方法来实现method swizzling：method_exchangeImplementations 交换2个方法中的IMP（IMPlication）；class_replaceMethod 修改类；利用 method_setImplementation直接设置某个方法的IMP。这些方法的声明都写在runtime.h中。 1.method_exchangeImplementations method_exchangeImplementations通过交换两个方法的IMP实现hook的，通过method_exchangeImplementations(A_Method, B_Method);可以实现如下图的交换。 2.method_setImplementation method_setImplementation直接设置更改某个方法的IMP。如下图，假设有方法A，我们想要把它的实现替换为方法B的实现，但又不想改变方法B的实现，就可以使用method_setImplementation，直接把A的IMP设置为B的IMP。 3.class_replaceMethod class_replaceMethod其实相当于class_addMethod和method_setImplementation的一个结合。 当调用class_replaceMethod(cls, name, imp, types)时，将把属于cls类的name方法实现指向imp。如果cls类原本没有name方法，就相当于调用class_addMethod给cls类增添了一个方法及其实现，这个方法的返回类型由types给定。如果cls类原本就有name方法，就相当于调用method_setImplementation更改了name方法的实现为imp，返回类型由替换的实现imp决定，给定types将被忽略。 参考Objective-C的hook方案（一）: Method SwizzlingHook 原理之 Method Swizzling]]></content>
      <categories>
        <category>objective-c基础</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>hook</tag>
      </tags>
  </entry>
</search>
